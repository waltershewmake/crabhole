#![feature(async_closure)]

static COMMANDS: &[&str] = &[
    "zsh",
    "ping 192.168.2.1 -c 15",
    "ping 192.168.1.1 -c 10",
];

use std::{
    io::{BufRead, BufReader, Read, Write},
    time::Duration,
};

use nix::sys::termios::InputFlags;
use portable_pty::CommandBuilder;
use tokio::{select, spawn, time::sleep};
use tokio_util::sync::CancellationToken;

async fn output_loop(control: CancellationToken, reader: Box<dyn Read + Send>) {
    let mut reader = BufReader::new(reader);
    let mut line = String::new();
    while !control.is_cancelled() {
        line.clear();
        let n = reader.read_line(&mut line).unwrap();
        if n == 0 {
            break;
        }
        print!("{}", line);
    }
}

async fn write_loop(control: CancellationToken, writer: Box<dyn Write + Send>) {
    let mut writer = writer;
    for command in COMMANDS {
        sleep(Duration::from_secs(1)).await;
        if control.is_cancelled() {
            break;
        }
        writer.write_all(command.as_bytes()).unwrap();
        writer.write_all(b"\n").unwrap();
    }
}

#[tokio::main]
async fn main() {
    let control = CancellationToken::new();

    let size = crossterm::terminal::size().unwrap();
    let size = portable_pty::PtySize {
        rows: size.1 as u16,
        cols: size.0 as u16,
        pixel_width: 0,
        pixel_height: 0,
    };
    let pty = portable_pty::native_pty_system().openpty(size).unwrap();
    let slave = pty.slave;

    let mut command = CommandBuilder::new("bash");
    command.arg("--login");

    let mut s = slave.spawn_command(command).unwrap();
    let pid = s.process_id().unwrap();

    let master = pty.master;

    let mut termios = master.get_termios().unwrap();

    let writer = master.take_writer().unwrap();
    spawn(write_loop(control.clone(), writer));

    let reader = master.try_clone_reader().unwrap();
    spawn(output_loop(control.clone(), reader));

    loop {
        select! {
            _ = tokio::time::sleep(std::time::Duration::from_secs(15)) => {
                println!("timeout");
                break;
            }
            _ = tokio::signal::ctrl_c() => {
                println!("ctrl-c");
                // forward ctrl-c to the child process
                unsafe {
                    println!("{}", libc::killpg(pid as i32, libc::SIGINT));
                }
            }
        }

    }

    // termios.input_flags |= InputFlags::BRKINT
    //     | InputFlags::ICRNL
    //     | InputFlags::IXON
    //     | InputFlags::IXOFF
    //     | InputFlags::IMAXBEL
    //     | InputFlags::IUTF8;

    unsafe {
        libc::kill(pid as i32, libc::SIGINT);
    }
    control.cancel();
}
